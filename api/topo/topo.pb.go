// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/topo/topo.proto

// Package topo defines interfaces for managing network top

package topo

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Update_Type int32

const (
	Update_UNSPECIFIED Update_Type = 0
	Update_INSERT      Update_Type = 1
	Update_MODIFY      Update_Type = 2
	Update_DELETE      Update_Type = 3
)

var Update_Type_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "INSERT",
	2: "MODIFY",
	3: "DELETE",
}

var Update_Type_value = map[string]int32{
	"UNSPECIFIED": 0,
	"INSERT":      1,
	"MODIFY":      2,
	"DELETE":      3,
}

func (x Update_Type) String() string {
	return proto.EnumName(Update_Type_name, int32(x))
}

func (Update_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{6, 0}
}

type Entity_Kind int32

const (
	Entity_RIC         Entity_Kind = 0
	Entity_E2NODE      Entity_Kind = 1
	Entity_E2INTERFACE Entity_Kind = 2
	Entity_XNINTERFACE Entity_Kind = 3
)

var Entity_Kind_name = map[int32]string{
	0: "RIC",
	1: "E2NODE",
	2: "E2INTERFACE",
	3: "XNINTERFACE",
}

var Entity_Kind_value = map[string]int32{
	"RIC":         0,
	"E2NODE":      1,
	"E2INTERFACE": 2,
	"XNINTERFACE": 3,
}

func (x Entity_Kind) String() string {
	return proto.EnumName(Entity_Kind_name, int32(x))
}

func (Entity_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7, 0}
}

type Relationship_Kind int32

const (
	Relationship_CONTAINS   Relationship_Kind = 0
	Relationship_AGGREGATES Relationship_Kind = 1
)

var Relationship_Kind_name = map[int32]string{
	0: "CONTAINS",
	1: "AGGREGATES",
}

var Relationship_Kind_value = map[string]int32{
	"CONTAINS":   0,
	"AGGREGATES": 1,
}

func (x Relationship_Kind) String() string {
	return proto.EnumName(Relationship_Kind_name, int32(x))
}

func (Relationship_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{8, 0}
}

type WriteRequest struct {
	Id EntityID `protobuf:"bytes,2,opt,name=id,proto3,casttype=EntityID" json:"id,omitempty"`
	// The write batch, comprising a list of Update operations
	Updates []*Update `protobuf:"bytes,3,rep,name=updates,proto3" json:"updates,omitempty"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{0}
}
func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(m, src)
}
func (m *WriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

func (m *WriteRequest) GetId() EntityID {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *WriteRequest) GetUpdates() []*Update {
	if m != nil {
		return m.Updates
	}
	return nil
}

type WriteResponse struct {
}

func (m *WriteResponse) Reset()         { *m = WriteResponse{} }
func (m *WriteResponse) String() string { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()    {}
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{1}
}
func (m *WriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteResponse.Merge(m, src)
}
func (m *WriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteResponse proto.InternalMessageInfo

type ReadRequest struct {
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{2}
}
func (m *ReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRequest.Merge(m, src)
}
func (m *ReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRequest proto.InternalMessageInfo

type ReadResponse struct {
}

func (m *ReadResponse) Reset()         { *m = ReadResponse{} }
func (m *ReadResponse) String() string { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()    {}
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{3}
}
func (m *ReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadResponse.Merge(m, src)
}
func (m *ReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadResponse proto.InternalMessageInfo

type StreamMessageRequest struct {
}

func (m *StreamMessageRequest) Reset()         { *m = StreamMessageRequest{} }
func (m *StreamMessageRequest) String() string { return proto.CompactTextString(m) }
func (*StreamMessageRequest) ProtoMessage()    {}
func (*StreamMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{4}
}
func (m *StreamMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamMessageRequest.Merge(m, src)
}
func (m *StreamMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamMessageRequest proto.InternalMessageInfo

type StreamMessageResponse struct {
}

func (m *StreamMessageResponse) Reset()         { *m = StreamMessageResponse{} }
func (m *StreamMessageResponse) String() string { return proto.CompactTextString(m) }
func (*StreamMessageResponse) ProtoMessage()    {}
func (*StreamMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{5}
}
func (m *StreamMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamMessageResponse.Merge(m, src)
}
func (m *StreamMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamMessageResponse proto.InternalMessageInfo

type Update struct {
	Type   Update_Type `protobuf:"varint,1,opt,name=type,proto3,enum=topo.Update_Type" json:"type,omitempty"`
	Entity *Entity     `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`
}

func (m *Update) Reset()         { *m = Update{} }
func (m *Update) String() string { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()    {}
func (*Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{6}
}
func (m *Update) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Update.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Update.Merge(m, src)
}
func (m *Update) XXX_Size() int {
	return m.Size()
}
func (m *Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Update proto.InternalMessageInfo

func (m *Update) GetType() Update_Type {
	if m != nil {
		return m.Type
	}
	return Update_UNSPECIFIED
}

func (m *Update) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

// Entity represent "things"
type Entity struct {
	Kind Entity_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=topo.Entity_Kind" json:"kind,omitempty"`
	// Types that are valid to be assigned to Entity:
	//	*Entity_Ric_
	//	*Entity_E2Node_
	//	*Entity_E2Interface_
	//	*Entity_XnInterface_
	Entity        isEntity_Entity `protobuf_oneof:"entity"`
	Relationships []*Relationship `protobuf:"bytes,6,rep,name=relationships,proto3" json:"relationships,omitempty"`
}

func (m *Entity) Reset()         { *m = Entity{} }
func (m *Entity) String() string { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()    {}
func (*Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7}
}
func (m *Entity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity.Merge(m, src)
}
func (m *Entity) XXX_Size() int {
	return m.Size()
}
func (m *Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Entity proto.InternalMessageInfo

type isEntity_Entity interface {
	isEntity_Entity()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Entity_Ric_ struct {
	Ric *Entity_Ric `protobuf:"bytes,2,opt,name=ric,proto3,oneof" json:"ric,omitempty"`
}
type Entity_E2Node_ struct {
	E2Node *Entity_E2Node `protobuf:"bytes,3,opt,name=e2_node,json=e2Node,proto3,oneof" json:"e2_node,omitempty"`
}
type Entity_E2Interface_ struct {
	E2Interface *Entity_E2Interface `protobuf:"bytes,4,opt,name=e2_interface,json=e2Interface,proto3,oneof" json:"e2_interface,omitempty"`
}
type Entity_XnInterface_ struct {
	XnInterface *Entity_XnInterface `protobuf:"bytes,5,opt,name=xn_interface,json=xnInterface,proto3,oneof" json:"xn_interface,omitempty"`
}

func (*Entity_Ric_) isEntity_Entity()         {}
func (*Entity_E2Node_) isEntity_Entity()      {}
func (*Entity_E2Interface_) isEntity_Entity() {}
func (*Entity_XnInterface_) isEntity_Entity() {}

func (m *Entity) GetEntity() isEntity_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *Entity) GetKind() Entity_Kind {
	if m != nil {
		return m.Kind
	}
	return Entity_RIC
}

func (m *Entity) GetRic() *Entity_Ric {
	if x, ok := m.GetEntity().(*Entity_Ric_); ok {
		return x.Ric
	}
	return nil
}

func (m *Entity) GetE2Node() *Entity_E2Node {
	if x, ok := m.GetEntity().(*Entity_E2Node_); ok {
		return x.E2Node
	}
	return nil
}

func (m *Entity) GetE2Interface() *Entity_E2Interface {
	if x, ok := m.GetEntity().(*Entity_E2Interface_); ok {
		return x.E2Interface
	}
	return nil
}

func (m *Entity) GetXnInterface() *Entity_XnInterface {
	if x, ok := m.GetEntity().(*Entity_XnInterface_); ok {
		return x.XnInterface
	}
	return nil
}

func (m *Entity) GetRelationships() []*Relationship {
	if m != nil {
		return m.Relationships
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Entity) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Entity_Ric_)(nil),
		(*Entity_E2Node_)(nil),
		(*Entity_E2Interface_)(nil),
		(*Entity_XnInterface_)(nil),
	}
}

type Entity_Ric struct {
}

func (m *Entity_Ric) Reset()         { *m = Entity_Ric{} }
func (m *Entity_Ric) String() string { return proto.CompactTextString(m) }
func (*Entity_Ric) ProtoMessage()    {}
func (*Entity_Ric) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7, 0}
}
func (m *Entity_Ric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity_Ric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity_Ric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity_Ric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity_Ric.Merge(m, src)
}
func (m *Entity_Ric) XXX_Size() int {
	return m.Size()
}
func (m *Entity_Ric) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity_Ric.DiscardUnknown(m)
}

var xxx_messageInfo_Entity_Ric proto.InternalMessageInfo

type Entity_E2Node struct {
}

func (m *Entity_E2Node) Reset()         { *m = Entity_E2Node{} }
func (m *Entity_E2Node) String() string { return proto.CompactTextString(m) }
func (*Entity_E2Node) ProtoMessage()    {}
func (*Entity_E2Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7, 1}
}
func (m *Entity_E2Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity_E2Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity_E2Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity_E2Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity_E2Node.Merge(m, src)
}
func (m *Entity_E2Node) XXX_Size() int {
	return m.Size()
}
func (m *Entity_E2Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity_E2Node.DiscardUnknown(m)
}

var xxx_messageInfo_Entity_E2Node proto.InternalMessageInfo

type Entity_E2Interface struct {
}

func (m *Entity_E2Interface) Reset()         { *m = Entity_E2Interface{} }
func (m *Entity_E2Interface) String() string { return proto.CompactTextString(m) }
func (*Entity_E2Interface) ProtoMessage()    {}
func (*Entity_E2Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7, 2}
}
func (m *Entity_E2Interface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity_E2Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity_E2Interface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity_E2Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity_E2Interface.Merge(m, src)
}
func (m *Entity_E2Interface) XXX_Size() int {
	return m.Size()
}
func (m *Entity_E2Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity_E2Interface.DiscardUnknown(m)
}

var xxx_messageInfo_Entity_E2Interface proto.InternalMessageInfo

type Entity_XnInterface struct {
}

func (m *Entity_XnInterface) Reset()         { *m = Entity_XnInterface{} }
func (m *Entity_XnInterface) String() string { return proto.CompactTextString(m) }
func (*Entity_XnInterface) ProtoMessage()    {}
func (*Entity_XnInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{7, 3}
}
func (m *Entity_XnInterface) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity_XnInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity_XnInterface.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity_XnInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity_XnInterface.Merge(m, src)
}
func (m *Entity_XnInterface) XXX_Size() int {
	return m.Size()
}
func (m *Entity_XnInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity_XnInterface.DiscardUnknown(m)
}

var xxx_messageInfo_Entity_XnInterface proto.InternalMessageInfo

type Relationship struct {
	Kind Relationship_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=topo.Relationship_Kind" json:"kind,omitempty"`
	// Types that are valid to be assigned to Relationship:
	//	*Relationship_Contains_
	//	*Relationship_Aggregates_
	Relationship isRelationship_Relationship `protobuf_oneof:"relationship"`
}

func (m *Relationship) Reset()         { *m = Relationship{} }
func (m *Relationship) String() string { return proto.CompactTextString(m) }
func (*Relationship) ProtoMessage()    {}
func (*Relationship) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{8}
}
func (m *Relationship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relationship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relationship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relationship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relationship.Merge(m, src)
}
func (m *Relationship) XXX_Size() int {
	return m.Size()
}
func (m *Relationship) XXX_DiscardUnknown() {
	xxx_messageInfo_Relationship.DiscardUnknown(m)
}

var xxx_messageInfo_Relationship proto.InternalMessageInfo

type isRelationship_Relationship interface {
	isRelationship_Relationship()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Relationship_Contains_ struct {
	Contains *Relationship_Contains `protobuf:"bytes,2,opt,name=contains,proto3,oneof" json:"contains,omitempty"`
}
type Relationship_Aggregates_ struct {
	Aggregates *Relationship_Aggregates `protobuf:"bytes,4,opt,name=aggregates,proto3,oneof" json:"aggregates,omitempty"`
}

func (*Relationship_Contains_) isRelationship_Relationship()   {}
func (*Relationship_Aggregates_) isRelationship_Relationship() {}

func (m *Relationship) GetRelationship() isRelationship_Relationship {
	if m != nil {
		return m.Relationship
	}
	return nil
}

func (m *Relationship) GetKind() Relationship_Kind {
	if m != nil {
		return m.Kind
	}
	return Relationship_CONTAINS
}

func (m *Relationship) GetContains() *Relationship_Contains {
	if x, ok := m.GetRelationship().(*Relationship_Contains_); ok {
		return x.Contains
	}
	return nil
}

func (m *Relationship) GetAggregates() *Relationship_Aggregates {
	if x, ok := m.GetRelationship().(*Relationship_Aggregates_); ok {
		return x.Aggregates
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Relationship) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Relationship_Contains_)(nil),
		(*Relationship_Aggregates_)(nil),
	}
}

type Relationship_Contains struct {
	ContainerId string `protobuf:"bytes,1,opt,name=ContainerId,proto3" json:"ContainerId,omitempty"`
	ContaineeId string `protobuf:"bytes,2,opt,name=ContaineeId,proto3" json:"ContaineeId,omitempty"`
}

func (m *Relationship_Contains) Reset()         { *m = Relationship_Contains{} }
func (m *Relationship_Contains) String() string { return proto.CompactTextString(m) }
func (*Relationship_Contains) ProtoMessage()    {}
func (*Relationship_Contains) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{8, 0}
}
func (m *Relationship_Contains) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relationship_Contains) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relationship_Contains.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relationship_Contains) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relationship_Contains.Merge(m, src)
}
func (m *Relationship_Contains) XXX_Size() int {
	return m.Size()
}
func (m *Relationship_Contains) XXX_DiscardUnknown() {
	xxx_messageInfo_Relationship_Contains.DiscardUnknown(m)
}

var xxx_messageInfo_Relationship_Contains proto.InternalMessageInfo

func (m *Relationship_Contains) GetContainerId() string {
	if m != nil {
		return m.ContainerId
	}
	return ""
}

func (m *Relationship_Contains) GetContaineeId() string {
	if m != nil {
		return m.ContaineeId
	}
	return ""
}

type Relationship_Aggregates struct {
	AggregatorId string `protobuf:"bytes,1,opt,name=AggregatorId,proto3" json:"AggregatorId,omitempty"`
	AggregateeId string `protobuf:"bytes,2,opt,name=AggregateeId,proto3" json:"AggregateeId,omitempty"`
}

func (m *Relationship_Aggregates) Reset()         { *m = Relationship_Aggregates{} }
func (m *Relationship_Aggregates) String() string { return proto.CompactTextString(m) }
func (*Relationship_Aggregates) ProtoMessage()    {}
func (*Relationship_Aggregates) Descriptor() ([]byte, []int) {
	return fileDescriptor_5823f9f54b50fd8c, []int{8, 1}
}
func (m *Relationship_Aggregates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relationship_Aggregates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relationship_Aggregates.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relationship_Aggregates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relationship_Aggregates.Merge(m, src)
}
func (m *Relationship_Aggregates) XXX_Size() int {
	return m.Size()
}
func (m *Relationship_Aggregates) XXX_DiscardUnknown() {
	xxx_messageInfo_Relationship_Aggregates.DiscardUnknown(m)
}

var xxx_messageInfo_Relationship_Aggregates proto.InternalMessageInfo

func (m *Relationship_Aggregates) GetAggregatorId() string {
	if m != nil {
		return m.AggregatorId
	}
	return ""
}

func (m *Relationship_Aggregates) GetAggregateeId() string {
	if m != nil {
		return m.AggregateeId
	}
	return ""
}

func init() {
	proto.RegisterEnum("topo.Update_Type", Update_Type_name, Update_Type_value)
	proto.RegisterEnum("topo.Entity_Kind", Entity_Kind_name, Entity_Kind_value)
	proto.RegisterEnum("topo.Relationship_Kind", Relationship_Kind_name, Relationship_Kind_value)
	proto.RegisterType((*WriteRequest)(nil), "topo.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "topo.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "topo.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "topo.ReadResponse")
	proto.RegisterType((*StreamMessageRequest)(nil), "topo.StreamMessageRequest")
	proto.RegisterType((*StreamMessageResponse)(nil), "topo.StreamMessageResponse")
	proto.RegisterType((*Update)(nil), "topo.Update")
	proto.RegisterType((*Entity)(nil), "topo.Entity")
	proto.RegisterType((*Entity_Ric)(nil), "topo.Entity.Ric")
	proto.RegisterType((*Entity_E2Node)(nil), "topo.Entity.E2Node")
	proto.RegisterType((*Entity_E2Interface)(nil), "topo.Entity.E2Interface")
	proto.RegisterType((*Entity_XnInterface)(nil), "topo.Entity.XnInterface")
	proto.RegisterType((*Relationship)(nil), "topo.Relationship")
	proto.RegisterType((*Relationship_Contains)(nil), "topo.Relationship.Contains")
	proto.RegisterType((*Relationship_Aggregates)(nil), "topo.Relationship.Aggregates")
}

func init() { proto.RegisterFile("api/topo/topo.proto", fileDescriptor_5823f9f54b50fd8c) }

var fileDescriptor_5823f9f54b50fd8c = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xb6, 0xe3, 0xd4, 0x4d, 0x27, 0x4e, 0xea, 0x6e, 0x0b, 0xb5, 0x5c, 0x08, 0x91, 0x55, 0x50,
	0x24, 0xa4, 0x14, 0x99, 0x0b, 0x08, 0x55, 0x28, 0x3f, 0x6e, 0x63, 0x41, 0x5d, 0xb4, 0x71, 0x45,
	0x39, 0x55, 0x26, 0x5e, 0x52, 0x8b, 0x62, 0x1b, 0xdb, 0x95, 0xda, 0xb7, 0x40, 0xf0, 0x2c, 0x9c,
	0x78, 0x01, 0x8e, 0x3d, 0x72, 0x42, 0xa8, 0x7d, 0x0b, 0x4e, 0xc8, 0x6b, 0x3b, 0x59, 0x97, 0x5c,
	0xa2, 0xd9, 0xef, 0x9b, 0x6f, 0xf6, 0xdb, 0xcc, 0x78, 0x60, 0xdd, 0x09, 0xbd, 0x9d, 0x24, 0x08,
	0x03, 0xfa, 0xd3, 0x0d, 0xa3, 0x20, 0x09, 0x50, 0x35, 0x8d, 0xd5, 0x8d, 0x69, 0x30, 0x0d, 0x28,
	0xb0, 0x93, 0x46, 0x19, 0xa7, 0xd9, 0x20, 0xbd, 0x8d, 0xbc, 0x84, 0x60, 0xf2, 0xf9, 0x9c, 0xc4,
	0x09, 0xba, 0x07, 0x15, 0xcf, 0x55, 0x2a, 0x6d, 0xbe, 0xb3, 0xd2, 0x97, 0xfe, 0xfe, 0x7e, 0x50,
	0x33, 0xfc, 0xc4, 0x4b, 0x2e, 0xcd, 0x21, 0xae, 0x78, 0x2e, 0x7a, 0x04, 0xcb, 0xe7, 0xa1, 0xeb,
	0x24, 0x24, 0x56, 0x84, 0xb6, 0xd0, 0xa9, 0xeb, 0x52, 0x97, 0xde, 0x73, 0x44, 0x41, 0x5c, 0x90,
	0xda, 0x2a, 0x34, 0xf2, 0xaa, 0x71, 0x18, 0xf8, 0x31, 0xd1, 0x1a, 0x50, 0xc7, 0xc4, 0x71, 0xf3,
	0x5b, 0xb4, 0x26, 0x48, 0xd9, 0x31, 0xa7, 0xef, 0xc2, 0xc6, 0x38, 0x89, 0x88, 0xf3, 0xe9, 0x80,
	0xc4, 0xb1, 0x33, 0x2d, 0xdc, 0x68, 0x9b, 0x70, 0xe7, 0x16, 0x9e, 0x0b, 0xbe, 0xf2, 0x20, 0x66,
	0x97, 0xa2, 0x87, 0x50, 0x4d, 0x2e, 0x43, 0xa2, 0xf0, 0x6d, 0xbe, 0xd3, 0xd4, 0xd7, 0x58, 0x43,
	0x5d, 0xfb, 0x32, 0x24, 0x98, 0xd2, 0x68, 0x1b, 0x44, 0x42, 0x9f, 0x42, 0x1f, 0x37, 0x73, 0x9e,
	0x3d, 0x0f, 0xe7, 0x9c, 0xf6, 0x02, 0xaa, 0xa9, 0x06, 0xad, 0x42, 0xfd, 0xc8, 0x1a, 0xbf, 0x31,
	0x06, 0xe6, 0x9e, 0x69, 0x0c, 0x65, 0x0e, 0x01, 0x88, 0xa6, 0x35, 0x36, 0xb0, 0x2d, 0xf3, 0x69,
	0x7c, 0x70, 0x38, 0x34, 0xf7, 0xde, 0xc9, 0x95, 0x34, 0x1e, 0x1a, 0xaf, 0x0d, 0xdb, 0x90, 0x05,
	0xed, 0xbb, 0x00, 0x62, 0x56, 0x2f, 0x35, 0xf5, 0xd1, 0xf3, 0xdd, 0xb2, 0xa9, 0x8c, 0xeb, 0xbe,
	0xf2, 0x7c, 0x17, 0x53, 0x1a, 0x6d, 0x83, 0x10, 0x79, 0x93, 0xdc, 0x91, 0x5c, 0xca, 0xc2, 0xde,
	0x64, 0xc4, 0xe1, 0x94, 0x46, 0x5d, 0x58, 0x26, 0xfa, 0x89, 0x1f, 0xb8, 0x44, 0x11, 0x68, 0xe6,
	0x7a, 0x29, 0xd3, 0xd0, 0xad, 0xc0, 0x25, 0x23, 0x0e, 0x8b, 0x84, 0x46, 0x68, 0x17, 0x24, 0xa2,
	0x9f, 0x78, 0x7e, 0x42, 0xa2, 0x0f, 0xce, 0x84, 0x28, 0x55, 0x2a, 0x52, 0x6e, 0x89, 0xcc, 0x82,
	0x1f, 0x71, 0xb8, 0x4e, 0xe6, 0xc7, 0x54, 0x7e, 0xe1, 0x33, 0xf2, 0xa5, 0x05, 0xf2, 0x63, 0xbf,
	0x24, 0xbf, 0x98, 0x1f, 0xd1, 0x33, 0x68, 0x44, 0xe4, 0xcc, 0x49, 0xbc, 0xc0, 0x8f, 0x4f, 0xbd,
	0x30, 0x56, 0x44, 0x3a, 0x29, 0x28, 0xd3, 0x63, 0x86, 0xc2, 0xe5, 0x44, 0x75, 0x09, 0x04, 0xec,
	0x4d, 0xd4, 0x1a, 0x88, 0xd9, 0x93, 0xd4, 0x06, 0xd4, 0x19, 0x9f, 0xe9, 0x91, 0xb9, 0x57, 0xdb,
	0x85, 0x6a, 0xfa, 0x57, 0xa2, 0x65, 0x10, 0xb0, 0x39, 0xc8, 0x7a, 0x64, 0xe8, 0xd6, 0xe1, 0xd0,
	0x90, 0xf9, 0xb4, 0x81, 0x86, 0x6e, 0x5a, 0xb6, 0x81, 0xf7, 0x7a, 0x03, 0x43, 0xae, 0xa4, 0xc0,
	0xb1, 0x35, 0x07, 0x84, 0x7e, 0xad, 0x18, 0x08, 0xed, 0x9b, 0x90, 0x8e, 0xe3, 0xdc, 0x09, 0x7a,
	0x5c, 0xea, 0xde, 0xe6, 0xff, 0xce, 0xd9, 0x1e, 0x3e, 0x87, 0xda, 0x24, 0xf0, 0x13, 0xc7, 0xf3,
	0xe3, 0xbc, 0x91, 0x5b, 0x0b, 0x04, 0x83, 0x3c, 0x65, 0xc4, 0xe1, 0x59, 0x3a, 0x7a, 0x09, 0xe0,
	0x4c, 0xa7, 0x11, 0x99, 0xd2, 0x2f, 0x2a, 0x6b, 0xd3, 0xfd, 0x05, 0xe2, 0xde, 0x2c, 0x69, 0xc4,
	0x61, 0x46, 0xa2, 0x5a, 0x50, 0x2b, 0x0a, 0xa3, 0x36, 0xd4, 0xf3, 0x98, 0x44, 0x66, 0xe6, 0x7d,
	0x05, 0xb3, 0x10, 0x9b, 0x41, 0xcc, 0xfc, 0x23, 0xc7, 0x2c, 0xa4, 0xda, 0x00, 0xf3, 0xbb, 0x90,
	0x06, 0x52, 0x71, 0x0a, 0xe6, 0x25, 0x4b, 0x18, 0x9b, 0xc3, 0x14, 0x2d, 0x61, 0xda, 0x76, 0xde,
	0x28, 0x09, 0x6a, 0x83, 0x43, 0xcb, 0xee, 0x99, 0xd6, 0x58, 0xe6, 0x50, 0x13, 0xa0, 0xb7, 0xbf,
	0x8f, 0x8d, 0xfd, 0x9e, 0x6d, 0x8c, 0x65, 0xbe, 0xdf, 0x04, 0x89, 0x1d, 0x07, 0xfd, 0x07, 0x0f,
	0x74, 0x71, 0x21, 0x1d, 0x96, 0xe8, 0x32, 0x41, 0xf9, 0x08, 0xb1, 0xfb, 0x4a, 0x5d, 0x2f, 0x61,
	0xf9, 0x76, 0xe0, 0xd0, 0x0e, 0x54, 0xd3, 0x05, 0x83, 0xd6, 0x8a, 0x7f, 0x73, 0xb6, 0x7b, 0x54,
	0xc4, 0x42, 0x33, 0x81, 0x05, 0x8d, 0x6c, 0xd3, 0x0c, 0x4e, 0x1d, 0xdf, 0x27, 0x67, 0x48, 0xcd,
	0xd2, 0x16, 0xad, 0x25, 0x75, 0x6b, 0x21, 0x57, 0xd4, 0xea, 0xf0, 0x4f, 0xf8, 0xbe, 0xf2, 0xf3,
	0xba, 0xc5, 0x5f, 0x5d, 0xb7, 0xf8, 0x3f, 0xd7, 0x2d, 0xfe, 0xcb, 0x4d, 0x8b, 0xbb, 0xba, 0x69,
	0x71, 0xbf, 0x6e, 0x5a, 0xdc, 0x7b, 0x91, 0x2e, 0xde, 0xa7, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff,
	0x14, 0x5b, 0xe2, 0xd7, 0xab, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TopoClient is the client API for Topo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TopoClient interface {
	// Update one or more entities to the topology
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	// Read one or more entities from topology
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	// Represents the bidirectional stream between
	// onos-topo and a client for the purpose of
	// - streaming notifications
	StreamChannel(ctx context.Context, opts ...grpc.CallOption) (Topo_StreamChannelClient, error)
}

type topoClient struct {
	cc *grpc.ClientConn
}

func NewTopoClient(cc *grpc.ClientConn) TopoClient {
	return &topoClient{cc}
}

func (c *topoClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := c.cc.Invoke(ctx, "/topo.topo/Write", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topoClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := c.cc.Invoke(ctx, "/topo.topo/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topoClient) StreamChannel(ctx context.Context, opts ...grpc.CallOption) (Topo_StreamChannelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Topo_serviceDesc.Streams[0], "/topo.topo/StreamChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &topoStreamChannelClient{stream}
	return x, nil
}

type Topo_StreamChannelClient interface {
	Send(*StreamMessageRequest) error
	Recv() (*StreamMessageResponse, error)
	grpc.ClientStream
}

type topoStreamChannelClient struct {
	grpc.ClientStream
}

func (x *topoStreamChannelClient) Send(m *StreamMessageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *topoStreamChannelClient) Recv() (*StreamMessageResponse, error) {
	m := new(StreamMessageResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TopoServer is the server API for Topo service.
type TopoServer interface {
	// Update one or more entities to the topology
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	// Read one or more entities from topology
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	// Represents the bidirectional stream between
	// onos-topo and a client for the purpose of
	// - streaming notifications
	StreamChannel(Topo_StreamChannelServer) error
}

// UnimplementedTopoServer can be embedded to have forward compatible implementations.
type UnimplementedTopoServer struct {
}

func (*UnimplementedTopoServer) Write(ctx context.Context, req *WriteRequest) (*WriteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (*UnimplementedTopoServer) Read(ctx context.Context, req *ReadRequest) (*ReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedTopoServer) StreamChannel(srv Topo_StreamChannelServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamChannel not implemented")
}

func RegisterTopoServer(s *grpc.Server, srv TopoServer) {
	s.RegisterService(&_Topo_serviceDesc, srv)
}

func _Topo_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopoServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/topo.topo/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopoServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topo_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopoServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/topo.topo/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopoServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Topo_StreamChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TopoServer).StreamChannel(&topoStreamChannelServer{stream})
}

type Topo_StreamChannelServer interface {
	Send(*StreamMessageResponse) error
	Recv() (*StreamMessageRequest, error)
	grpc.ServerStream
}

type topoStreamChannelServer struct {
	grpc.ServerStream
}

func (x *topoStreamChannelServer) Send(m *StreamMessageResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *topoStreamChannelServer) Recv() (*StreamMessageRequest, error) {
	m := new(StreamMessageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Topo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "topo.topo",
	HandlerType: (*TopoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _Topo_Write_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _Topo_Read_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChannel",
			Handler:       _Topo_StreamChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/topo/topo.proto",
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTopo(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StreamMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StreamMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Entity != nil {
		{
			size, err := m.Entity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTopo(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relationships) > 0 {
		for iNdEx := len(m.Relationships) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relationships[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTopo(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Entity != nil {
		{
			size := m.Entity.Size()
			i -= size
			if _, err := m.Entity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Kind != 0 {
		i = encodeVarintTopo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entity_Ric_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_Ric_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ric != nil {
		{
			size, err := m.Ric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Entity_E2Node_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_E2Node_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.E2Node != nil {
		{
			size, err := m.E2Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Entity_E2Interface_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_E2Interface_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.E2Interface != nil {
		{
			size, err := m.E2Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Entity_XnInterface_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_XnInterface_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.XnInterface != nil {
		{
			size, err := m.XnInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Entity_Ric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_Ric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_Ric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Entity_E2Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_E2Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_E2Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Entity_E2Interface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_E2Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_E2Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Entity_XnInterface) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_XnInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity_XnInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Relationship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relationship) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Relationship != nil {
		{
			size := m.Relationship.Size()
			i -= size
			if _, err := m.Relationship.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Kind != 0 {
		i = encodeVarintTopo(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Relationship_Contains_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship_Contains_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Contains != nil {
		{
			size, err := m.Contains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Relationship_Aggregates_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship_Aggregates_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aggregates != nil {
		{
			size, err := m.Aggregates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTopo(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Relationship_Contains) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relationship_Contains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship_Contains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContaineeId) > 0 {
		i -= len(m.ContaineeId)
		copy(dAtA[i:], m.ContaineeId)
		i = encodeVarintTopo(dAtA, i, uint64(len(m.ContaineeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContainerId) > 0 {
		i -= len(m.ContainerId)
		copy(dAtA[i:], m.ContainerId)
		i = encodeVarintTopo(dAtA, i, uint64(len(m.ContainerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Relationship_Aggregates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relationship_Aggregates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship_Aggregates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AggregateeId) > 0 {
		i -= len(m.AggregateeId)
		copy(dAtA[i:], m.AggregateeId)
		i = encodeVarintTopo(dAtA, i, uint64(len(m.AggregateeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AggregatorId) > 0 {
		i -= len(m.AggregatorId)
		copy(dAtA[i:], m.AggregatorId)
		i = encodeVarintTopo(dAtA, i, uint64(len(m.AggregatorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTopo(dAtA []byte, offset int, v uint64) int {
	offset -= sovTopo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WriteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTopo(uint64(l))
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovTopo(uint64(l))
		}
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StreamMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StreamMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTopo(uint64(m.Type))
	}
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}

func (m *Entity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovTopo(uint64(m.Kind))
	}
	if m.Entity != nil {
		n += m.Entity.Size()
	}
	if len(m.Relationships) > 0 {
		for _, e := range m.Relationships {
			l = e.Size()
			n += 1 + l + sovTopo(uint64(l))
		}
	}
	return n
}

func (m *Entity_Ric_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ric != nil {
		l = m.Ric.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Entity_E2Node_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.E2Node != nil {
		l = m.E2Node.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Entity_E2Interface_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.E2Interface != nil {
		l = m.E2Interface.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Entity_XnInterface_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XnInterface != nil {
		l = m.XnInterface.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Entity_Ric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Entity_E2Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Entity_E2Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Entity_XnInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Relationship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovTopo(uint64(m.Kind))
	}
	if m.Relationship != nil {
		n += m.Relationship.Size()
	}
	return n
}

func (m *Relationship_Contains_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Contains != nil {
		l = m.Contains.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Relationship_Aggregates_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aggregates != nil {
		l = m.Aggregates.Size()
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}
func (m *Relationship_Contains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovTopo(uint64(l))
	}
	l = len(m.ContaineeId)
	if l > 0 {
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}

func (m *Relationship_Aggregates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AggregatorId)
	if l > 0 {
		n += 1 + l + sovTopo(uint64(l))
	}
	l = len(m.AggregateeId)
	if l > 0 {
		n += 1 + l + sovTopo(uint64(l))
	}
	return n
}

func sovTopo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTopo(x uint64) (n int) {
	return sovTopo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = EntityID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &Update{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Update_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &Entity{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Entity_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_Ric{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Entity_Ric_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_E2Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Entity_E2Node_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E2Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_E2Interface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Entity_E2Interface_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XnInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_XnInterface{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entity = &Entity_XnInterface_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relationships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relationships = append(m.Relationships, &Relationship{})
			if err := m.Relationships[len(m.Relationships)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_Ric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_E2Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: E2Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: E2Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_E2Interface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: E2Interface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: E2Interface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_XnInterface) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XnInterface: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XnInterface: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relationship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relationship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relationship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Relationship_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Relationship_Contains{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Relationship = &Relationship_Contains_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Relationship_Aggregates{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Relationship = &Relationship_Aggregates_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relationship_Contains) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contains: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contains: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContaineeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContaineeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relationship_Aggregates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTopo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTopo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregateeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTopo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTopo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTopo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTopo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTopo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTopo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTopo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTopo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTopo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTopo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTopo = fmt.Errorf("proto: unexpected end of group")
)
