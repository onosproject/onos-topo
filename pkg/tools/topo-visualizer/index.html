<!--
SPDX-FileCopyrightText: 2022-present Open Networking Foundation <info@opennetworking.org>
SPDX-License-Identifier: Apache-2.0
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style> body {
        margin: 0;
    } </style>
    <script src="//unpkg.com/force-graph"></script>
</head>
<body>
<div id="graph"></div>
<script>
    const canvas = document.getElementById("graph");
    let nodes = [], links = [];

    const Graph = ForceGraph()(canvas)
        //.onNodeClick(inspectNode)
        .graphData({nodes: nodes, links: links})
        .nodeCanvasObject((node, ctx, globalScale) => {
            const label = node.id;
            const fontSize = 12 / globalScale;
            ctx.font = '' + fontSize + 'px Sans-Serif';
            const textWidth = ctx.measureText(label).width;
            const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#000';
            ctx.fillText(label, node.x, node.y);

            node.__bckgDimensions = bckgDimensions; // to re-use in nodePointerAreaPaint
        })
        .linkDirectionalArrowLength(5)
        .linkDirectionalArrowRelPos(1)
        .linkCanvasObjectMode(() => 'after')
        .linkCanvasObject((link, ctx, globalScale) => {
            const MAX_FONT_SIZE = 12 / globalScale;
            const LABEL_NODE_MARGIN = Graph.nodeRelSize() * 1.5;

            const start = link.source;
            const end = link.target;

            // ignore unbound links
            if (typeof start !== 'object' || typeof end !== 'object') return;

            // calculate label positioning
            const textPos = Object.assign(...['x', 'y'].map(c => ({
                [c]: start[c] + (end[c] - start[c]) / 2 // calc middle point
            })));

            const relLink = {x: end.x - start.x, y: end.y - start.y};

            const maxTextLength = Math.sqrt(Math.pow(relLink.x, 2) + Math.pow(relLink.y, 2)) - LABEL_NODE_MARGIN * 2;

            let textAngle = Math.atan2(relLink.y, relLink.x);
            // maintain label vertical orientation for legibility
            if (textAngle > Math.PI / 2) textAngle = -(Math.PI - textAngle);
            if (textAngle < -Math.PI / 2) textAngle = -(-Math.PI - textAngle);

            const label = link.data.id;

            // estimate fontSize to fit in link length
            ctx.font = '1px Sans-Serif';
            const fontSize = Math.min(MAX_FONT_SIZE, maxTextLength / ctx.measureText(label).width);
            ctx.font = '' + fontSize + 'px Sans-Serif';
            const textWidth = ctx.measureText(label).width;
            const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

            // draw text label (with background rect)
            ctx.save();
            ctx.translate(textPos.x, textPos.y);
            ctx.rotate(textAngle);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(-bckgDimensions[0] / 2, -bckgDimensions[1] / 2, ...bckgDimensions);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#555';
            ctx.fillText(label, 0, 0);
            ctx.restore();
        });

    let ws = new WebSocket("{{.}}");
    ws.onopen = function (evt) {
        console.log("Connected");
    }
    ws.onclose = function (evt) {
        console.log("Disconnected");
        ws = null;
    }
    ws.onerror = function (evt) {
        console.error("ERROR: " + evt.data);
    }
    ws.onmessage = function (evt) {
        let data = JSON.parse(evt.data);
        console.log(data);
        if (data.event === "replay" || data.event === "added") {
            if (data.entity) {
                nodes = [...nodes, {id: data.id, data: data}];
            } else if (data.relation) {
                links = [...links, {id: data.id, source: data.relation.src, target: data.relation.tgt, data: data}];
            }

        } else if (data.event === "updated") {
            if (data.entity) {
                update(nodes, data);
            } else if (data.relation) {
                update(links, data);
            }

        } else if (data.event === "removed") {
            if (data.entity) {
                nodes = remove(nodes, data.id);
            } else if (data.relation) {
                links = remove(links, data.id);
            }
        }
        console.log('nodes:', nodes, 'links:', links)
        Graph.graphData({nodes: nodes, links: links});
    }

    function update(list, data) {
        for (let i = 0; i < list.length; i++) {
            if (list[i].id === data.id) {
                list[id].data = data;
                return;
            }
        }
    }

    function remove(list, id) {
        for (let i = 0; i < list.length; i++) {
            if (list[i].id === id) {
                console.log("!removing", list[i])
                list.splice(i, 1);
                return list;
            }
        }
        return list
    }
</script>
</body>
</html>
